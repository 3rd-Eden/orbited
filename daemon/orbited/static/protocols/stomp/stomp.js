/* stomp.js
 *
 * JavaScript implementation of the STOMP (Streaming Text Oriented Protocol)
 *  for use with TCPConnection or a facsimile
 *
 * Frank Salim (frank.salim@gmail.com) (c) 2008 Orbited (orbited.org)
 * Rui Lopes (ruilopes.com)
 */

STOMP_DEBUG = false;

if (STOMP_DEBUG) {
    function getStompLogger(name) {
        return {
            debug: function() {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(name, ": ");
                console.debug.apply(console, args);
            },
            dir: function() {
                console.debug(name, ":");
                console.dir.apply(console, arguments);
            }
        };
    }
} else {
    function getStompLogger(name) {
        return {
            debug: function() {},
            dir: function() {}
        };
    }
}


// Implement Array.indexOf (needed in IE 7 or lower).
// NB: This was borrowed from Mozilla.
// See http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(elt /*, from*/) {
        var len = this.length;
        var from = Number(arguments[1]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
            from += len;
        
        for (; from < len; from++) {
            if (from in this && this[from] === elt)
                return from;
        }
        return -1;
    };
}


// NB: This is loosly based on twisted.protocols.basic.LineReceiver
//     See http://twistedmatrix.com/documents/8.1.0/api/twisted.protocols.basic.LineReceiver.html
LineProtocol = function(transport) {
    var log = getStompLogger("LineProtocol");
    var self = this;
    var buffer = null;
    var isLineMode = true;

    //
    // Transport callbacks implementation.
    //

    transport.onopen = function() {
        buffer = [];
        isLineMode = true;
        self.onopen();
    };

    transport.onclose = function() {
        buffer = null;
        self.onclose();
    };

    transport.onerror = function(error) {
        self.onerror(error);
    };

    transport.onread = function(data) {
        log.debug("transport.onread: enter isLineMode=", isLineMode, " buffer=", buffer, " data=", data);

        if (isLineMode) {
            buffer.push.apply(buffer, data);
            data = [];

            var start = 0;
            var end;
            while ((end = buffer.indexOf(10, start)) >= 0 && isLineMode) {
                // TODO it would be nice that bytesToUTF8 received the
                //      start and end indexes, if it did, we didn't
                //      need the slice copy.
                var bytes = buffer.slice(start, end);
                var line = bytesToUTF8(bytes);
                self.onlinereceived(line);
                start = end + 1;
            }
            // remove the portion (head) of the array we've processed.
            buffer.splice(0, start);

            if (isLineMode) {
                // TODO if this buffer length is above a given threshold, we should
                //      send an alert "max line length exceeded" and empty buffer
                //      or even abort.
            } else {
                // we've left the line mode and what remains in buffer is raw data.
                data = buffer;
                buffer = [];
            }
        }

        if (data.length > 0) {
            self.onrawdatareceived(data);
        }

        log.debug("transport.onread: leave");
    };

    //
    // Protocol implementation.
    //

    self.setRawMode = function() {
        log.debug("setRawMode");
        isLineMode = false;
    };

    // TODO although this is a nice interface, it will do a extra copy
    //      of the data, a probable better alternative would be to
    //      make onrawdatareceived return the number of consumed bytes
    //      (instead of making it comsume all the given data).
    self.setLineMode = function(extra) {
        log.debug("setLineMode: extra=", extra);
        isLineMode = true;
        if (extra && extra.length > 0)
            transport.onread(extra);
    };

    self.send = function(data) {
        return transport.send(data);
    };

    self.close = function() {
        transport.close();
    };

    //
    // callbacks for the events generated by this
    //
    // XXX these callbacks names should be camelCased

    self.onopen = function() {};
    self.onclose = function() {};
    self.onerror = function(error) {};
    self.onlinereceived = function(line) {};
    self.onrawdatareceived = function(data) {};
};


// TODO propose to rename this to BaseStompClient
//      See the comment in the callbacks zone bellow.
// TODO add ";" to all lines (where it makes sense).
STOMPClient = function() {
    var log = getStompLogger("STOMPClient");
    var self = this
    // TODO should we really save this?
    self.user = null

    // Callbacks
    // TODO rename these to onXXXFrame?
    //      the ideia is, this should be a bare bone StompClient,
    //      sugar stuff should be implemented in a different
    //      object (where we could try out different API without
    //      borking the raw interface).
    self.onopen = null
    self.onclose = null
    self.onmessage = null
    self.onerror = null

    var protocol = null;
    var buffer = [];
    var type = null;
    var headers = null;

    // TODO probably this function should be move into a common base...
    function trim(str) {
        // See http://blog.stevenlevithan.com/archives/faster-trim-javascript
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function onLineReceived(line) {
        log.debug("onLineReceived: line=", line);

        if (line.length == 0) {
            // ignore empty lines before the type line.
            if (type === null)
                return;
            // we reached the end headers.
            log.debug("onLineReceived: all headers:");
            log.dir(headers);
            protocol.setRawMode();
            // TODO parse content-length header and receive that many
            //      bytes in onRawDataReceived.
            return;
        }

        if (type === null) {
            log.debug("onLineReceived: begin ", line, " frame");
            type = line;
            headers = {};
            return;
        }

        var sep = line.search(":");
        var key = trim(line.slice(0, sep));
        var value = trim(line.slice(sep + 1));
        headers[key] = value;
        log.debug("onLineReceived: found header ", key, "=", value);
    }

    function onRawDataReceived(data) {
        log.debug("onRawDataReceived: data.length=", data.length);
        buffer.push.apply(buffer, data);

        var end = buffer.indexOf(0);
        if (end >= 0) {
            // split into head (bytes) and tail (buffer).
            var bytes = buffer.splice(0, end + 1);
            // remove NUL.
            // TODO when bytesToUTF8 accepts an end index, remove this pop.
            bytes.pop();

            var frame = {
                type: type,
                headers: headers,
                body: bytesToUTF8(bytes)
            };

            log.debug("onRawDataReceived: end frame");
            log.dir(frame);

            dispatch(frame);

            type = null;
            headers = {};
            data = buffer;
            buffer = [];
            protocol.setLineMode(data);
        }
    }

    function dispatch(frame) {
        switch (frame.type) {
            case 'CONNECTED':
                // TODO rename to onconnected and leave the onopen to
                //      notify the user when the transport is open?
                self.onopen();
                break;
            case 'MESSAGE':
                self.onmessage(frame);
                break;
            case 'RECEIPT':
                // TODO: receipts and acking modes
                break;
            case 'ERROR':
                self.onerror(frame);
                break;
            default:
                throw("Unknown STOMP frame type " + frame.type);
        }
    }

    /* Messaging methods
     *
     */
     var send_frame = function(type, headers, body) {
        var frame = ""
        frame += type + "\n"
        for (var key in headers)
            frame += key + ":" + headers[key] + "\n"
        frame += "\n"                   // end of headers
        if (body)
            frame += body
        frame += "\0"                   // frame delineator
        protocol.send(UTF8ToBytes(frame))
    }
    // XXX why is this public?  even though we can send custom frames,
    //     there is no way (dispatch is private) to receive custom
    //     replies.
    self.send_frame = send_frame

    /* Client Actions
     *
     */
    self.connect = function(domain, port, user, password) {
        self.buffer = []                     // reset buffer state
        self.user = user
        function onopen() {
            send_frame("CONNECT", {'login': user, 'passcode':password})
        }
        protocol = self._createProtocol(domain, port);
        // XXX shouldn't LineProtocol/BinaryTCPSocket have an connect method?
        //     because the constructor will automatically try to connect before
        //     we have a chance to set event handlers (OK, this might not
        //     happen with current single threaded JS implementation, but I'm
        //     not sure about that...).
        protocol.onopen = onopen
        // XXX even though we are connecting to onclose, this never gets fired
        //     after we shutdown orbited.
        protocol.onclose = self.onclose
        // TODO what should we do when there is a protocol error?
        //      XXX this is also triggered when we receive an ERROR frame!
        protocol.onerror = self.onerror
        protocol.onlinereceived = onLineReceived
        protocol.onrawdatareceived = onRawDataReceived
    }

    // NB: this is needed for the unit tests.
    self._createProtocol = function(domain, port) {
        return new LineProtocol(new BinaryTCPSocket(domain, port));
    };

    self.disconnect = function() {
        send_frame("DISCONNECT", {})
    }

    self.send = function(msg, destination, custom_headers) {
        var headers = {"destination": destination}
        if (custom_headers)
            for (var key in custom_headers)
                headers[key] = custom_headers[key]
            
        send_frame("SEND", headers, msg)
    }

    self.subscribe = function(destination) {
        send_frame("SUBSCRIBE", {"destination": destination})
    }
    
    self.unsubscribe = function(destination) {
        send_frame("UNSUBSCRIBE", {"destination": destination})
    }

    /* Transactions and acking
     *
     */
    self.begin = function(id) {
        send_frame("BEGIN", {"transaction": id})
    }

    self.commit = function(id) {
        send_frame("COMMIT", {"transaction": id})
    }

    // Rolls back the given transaction
    self.abort = function(id) {
        send_frame("ABORT", {"transaction": id})
    }

    self.ack = function(message_id, transaction_id) {
        //throw("ack: not implemented")
    }
}
