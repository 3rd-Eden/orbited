                Slide: Orbited (Michael Carter and Jacob Rus)

M: Hi, my name is Michael Carter. I'm the founder of the Orbited project which I've been working on for two years. Orbited is an MIT licensed Comet server built for scalability and integration.

J: And I'm Jacob Rus. I've been working with Michael on Orbited for about a year and a half.  And I'm going to tell you about some exciting recent developments in Orbited that might change your lives forever.

M: So, to start us off I'd like to ask a question. How many of you in this room have used Comet in your applications?

    (hands raise)

                Slide: many responses to a single request

M: Ok, so this talk should help those of you with your hands up as well as your hands down. Just to make sure we're all on the same page, how about a definition? Comet is (TODO)

J: Wait a second, Michael.  That sounds an awful lot like a socket. 

M: A Tcp socket?

                Slide: TCP

J: yeah, TCP -- Full-duplex, Bi-directional communication between the client and server...

J: How many of you have used TCP sockets in your applications?

    (hands raise)

J: All network programming for decades has been written on top of the same straight-forward abstraction.  We have a bi-directional communication channel, where each end has a write function for sending data, and a way to attach callbacks for reading data written at the other end.

M: Well no, it's not a socket.

                Slide: Flash sockets and Java sockets with an X through them

M: Sockets don't work on the web. We've had sockets in Flash and Java for a long time, but there is a show-stopping problem. That is, they don't interoperate over routers and firewalls. You can't deploy an application that will fail on at any school, government, or coroporate office. 

J: Ok then.  If it's not a socket, what *is* the architecture of Comet?

                Slide: typical web framework

M: So we already know about a typical web application deployment. You have your web framework and you construct Rich internet applications using AJAX for the upstream. When I say upstream, I mean when the browser sends asynchronous notification to the server. Downstream, on the other hand, is asynchronous notification from the browser to the server. 

                Slide: web framework + comet server

M: In order to do downstream, we add a Comet server beside the web applciation. Downstream data flows from the the  web application, to the comet server, and then to the browser.

J: But what does the javascript API look like?

                Slide: JS API

M: Well, for upstream its just XHR, and for downstream its Comet.receive(cb), where the cb is a function that takes data. Other comet servers have variations on this API, but its basically the same.

J: So you have a way to send, and a way to read data?

M: right.

                Slide: TCPSocket API

J: That sounds like a socket. why not just make the api a TCPSocket then. It has a connect function, a send function, and an onread callback.

M: So, Remember that red thing in your salad earlier today, the Tomato.  The one that you insisted was a to mah toe? Thats what this is about -- word games. Ok then, call it a TCPSocket, it doesn't change what it is.

J: Well, how would you make a web-based IRC client with Comet?

M: So you admit you're playing word games?

J: No, I'm building an argument. Bear with me -- how would you create a web-based IRC client with Comet

                Slide: of IRC bridge

M: Well, we have a way to do bi-directional communication from and to the web app, so now we built a bridge to IRC. The web app opens an IRC connection for each user. If a user wants to send a private message, the browser makes an ajax request to the app with the content of the message. The app makes a call to the irc client to send the message. When a user receives a message, the application turns it into a json data structure representing the message and has the comet server dispatch it to the appropriate browser.

J: Is the browser actually getting all the information that a Desktop client would get?

M: Of course. All we're doing is encoding those frames in json, but we still send all of the data. The IRC web client can do just as much as a desktop client.

J: Ok, so what about a Jabber client in the browser?

                Slide: of Jabber bridge

M: Same deal. We create a jabber connection on the web app for each user connected. When we receive frames, we send a representation of them to the browser via the comet server.

                Slide: Ajaxian "[they] now like to call..."

J: So this is my point. I say, lets call this TCPSocket, and many people say, oh, word games. Now you like to call Comet TCPSocket. Like this ajaxian article for instance.

J: But really, its about integration. You are proposing that we write a server-side bridge for each back-end system we want to integrate with. But with that method, or life is ahead of us because what we're *really* doing is writing a new protocol json based protocol for each existing protocol, and then writing a server-side trans-coder.

M: Slow down there. We aren't creating any new protocols, just bridge the protocols to the browser.

J: No, actually you are. You aren't actually sending RAW irc to the browser, you're sending JSON encoded IRC. So you need a new transcoder for every protocol.

M: Thats not a big deal though. We could write a transcoder for the more popular protocols, and then write a tutorial on how to write your own for any protocol we don't support.

[Slide a bunch of protocols]
J: Its a waste a time. Tell me, what do these protocols all have in common?

M: They're all tcp?

[Slide: TCPSocket bridge ]
J: Exactly. They are TCP protocols. So thats my argument. Lets write a SINGLE bridge that takes raw TCP data and transcodes it to ajax/comet.

M: So in the case of the irc client you'd be getting *raw* irc data in the browser?

J: yes.

M: what good is that?

J: So you write an IRC client. You parse the IRC protocol. 

M: Yeah, but now you have to do more work in the browser. You'll be using extra cpu to parse IRC instead of just eval or safe evaling some json.

J: So what percentage of the processor would you say the browser uses doing this complicated processing?

[slide 10% of the processor to parse the protocol in JS ]
M: 10%

J: Sure. So, how much faster is C than javascript for parsing protocols
[slide 10% processor; c is 50x faster than js]
M: 50x

J: Ok, so then it would only take 0.2% of the processor for the server to parse that protocol for the browser, right?

M: sure.

[The math... = 500 users MAX]
J: That means that we would saturate the server with 500 users. So if you want any chance of scaling this stuff, you better not put it on the server!

M: I see what you did there! Okay, so maybe I exagerated. It would take probably 1% of the processor to parse the js protocol

[Slide: 500 vs. 100k]
J: Okay, then whats the problem? 1% of the cpu isn't a problem at all. The bottom line is this: If you parse the protocol on the server, scalability will be a big problem. On the other hand, letting the client do the processing is far better for distribution
